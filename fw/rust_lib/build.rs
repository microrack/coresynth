extern crate bindgen;
extern crate cbindgen;

use std::env;
use std::path::Path;

fn generate_app_bindings<P: AsRef<Path>>(crate_dir: P, pkg_name: &str) {
    cbindgen::generate(crate_dir)
        .expect("Unable to generate cbindgen bindings")
        .write_to_file(
            Path::new("bindings").join(format!("{}.h", pkg_name))
        );
}

fn main() {
    println!("cargo:rerun-if-env-changed=FORCE_BINDGEN");

    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let pkg_name = env::var("CARGO_PKG_NAME").unwrap();
    let out_path = env::var("OUT_DIR").unwrap();
    let force_bindgen: bool = std::env::var_os("FORCE_BINDGEN").is_some();
    let cmsis_os: bool = env::var_os("CARGO_FEATURE_CMSIS_OS").is_some();

    generate_app_bindings(crate_dir, &pkg_name);

    if cmsis_os {
        generate_cmsis_os_bindings(&out_path, force_bindgen);
    }

    // TODO wrap with feature
    generate_stm32_hal_bindings(&out_path, force_bindgen);
    generate_stm32_hal_statics(&out_path, force_bindgen);

    generate_glue_bindings(&out_path, force_bindgen);
}

const STM32_SDK_ROOT: &str = "../stm32f103c8t6";

fn stm32_builder() -> bindgen::Builder {
    let stm32_sdk_includes = [
        "Inc",
        "Drivers/STM32F1xx_HAL_Driver/Inc",
        "Drivers/STM32F1xx_HAL_Driver/Inc/Legacy",
        "Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM3",
        "Drivers/CMSIS/Device/ST/STM32F1xx/Include",
        "Middlewares/Third_Party/FreeRTOS/Source/include",
        "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS",
        "Drivers/CMSIS/Include",
    ];

    let stm32_sdk_includes = stm32_sdk_includes
        .iter()
        .map(|stm32_include| format!("{}/{}", STM32_SDK_ROOT, stm32_include));

    // TODO kill absolute path
    let includes = [
        "../glue",
        // This is bindings generated by cbindgen nearby
        "./bindings",
        "/usr/lib/gcc/arm-none-eabi/4.9.3/include",
        "/usr/lib/gcc/arm-none-eabi/4.9.3/../../../arm-none-eabi/include",
    ];

    #[rustfmt::skip]
    return bindgen::Builder::default()
        .use_core()

        .ctypes_prefix("self")
        .blacklist_type("__uint8_t")
        .blacklist_type("__uint32_t")
        .blacklist_type("c_int")
        .blacklist_type("__int32_t")

        // TODO there's no .no_debug method, to disable only for specific type
        .derive_debug(false)

        .clang_arg("-DUSE_HAL_DRIVER")
        .clang_arg("-DSTM32F103xB")

        .clang_args(
            (includes.iter().map(|x| From::from(x as &str)).chain(stm32_sdk_includes))
                .map(|include| format!("-I{}", include))
        )
        .clang_arg("--target=thumbv7m-none-eabi")
        .clang_arg("--verbose")
        .clang_arg("-nostdinc");
}

fn generate_cmsis_os_bindings<P: AsRef<Path>>(out_path: P, force: bool) {
    let result_path = out_path.as_ref().join("cmsis_os_bindings.rs");
    let should_build = !result_path.is_file() || force;
    if !should_build {
        return;
    }

    println!("cargo:warning=writing cmsis os bindings");

    #[rustfmt::skip]
    let builder = stm32_builder()
        .whitelist_recursively(false)

        .header(format!("{}/Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h", STM32_SDK_ROOT))

        .whitelist_type("osStatus")
        .rustified_enum("osStatus")

        .whitelist_type("osEvent")

        .whitelist_type("os_pthread")
        .whitelist_type("osThreadId")
        .opaque_type("osThreadId")
        .whitelist_type("os_thread_def")
        .whitelist_type("osThreadDef_t")
        .whitelist_type("osPriority")
        .rustified_enum("osPriority")
        .whitelist_function("osThreadCreate")
        .whitelist_function("osThreadGetId")
        .whitelist_function("osThreadTerminate")
        .whitelist_function("osThreadYield")

        .whitelist_type("osMutexId")
        .opaque_type("osMutexId")
        .whitelist_type("os_mutex_def")
        .whitelist_type("osMutexDef_t")
        .whitelist_function("osMutexCreate")
        .whitelist_function("osMutexWait")
        .whitelist_function("osMutexRelease")

        .whitelist_type("osSemaphoreId")
        .opaque_type("osSemaphoreId")
        .whitelist_type("os_semaphore_def")
        .whitelist_type("osSemaphoreDef_t")
        .whitelist_function("osSemaphoreCreate")
        .whitelist_function("osSemaphoreWait")
        .whitelist_function("osSemaphoreRelease")

        .whitelist_type("osMessageQId")
        .opaque_type("osMessageQId")

        .whitelist_type("osMailQId")
        .opaque_type("osMailQId")
        .whitelist_type("os_mailQ_def")
        .whitelist_type("osMailQDef_t")
        .whitelist_type("os_mailQ_cb")
        .whitelist_function("osMailCreate")
        .whitelist_function("osMailAlloc")
        .whitelist_function("osMailFree")
        .whitelist_function("osMailPut")
        .whitelist_function("osMailGet")

        .whitelist_var("osWaitForever")
        .whitelist_function("osDelay")

        // TODO for some reason, bindgen wont generate osKernelSysTickFrequency
        .whitelist_var("osKernelSysTickFrequency")
        .whitelist_function("osKernelSysTick")
    ;

    let bindings = builder.generate().expect("Unable to generate bindings");

    bindings
        .write_to_file(result_path)
        .expect("Couldn't write bindings!");
}

fn generate_glue_bindings<P: AsRef<Path>>(out_path: P, force: bool) {
    let result_path = out_path.as_ref().join("glue_bindings.rs");
    let should_build = !result_path.is_file() || force;
    if !should_build {
        return;
    }

    println!("cargo:warning=writing glue bindings");

    #[rustfmt::skip]
    let builder = stm32_builder()
        .whitelist_recursively(false)

        .header("../glue/glue.h")

        .whitelist_var("htim[0-9]+")

        .whitelist_type("TIM_HandleTypeDef")
        .opaque_type("TIM_HandleTypeDef")
        // bindgen can't handle defines with type casts
        .whitelist_var("TIM_CHANNEL_[0-9]+")
        .whitelist_function("set_pwm")

        .whitelist_function("system_reset")

        .whitelist_var("TICKS_FREQ")
    ;

    let bindings = builder.generate().expect("Unable to generate bindings");

    bindings
        .write_to_file(result_path)
        .expect("Couldn't write bindings!");
}

fn generate_stm32_hal_bindings<P: AsRef<Path>>(out_path: P, force: bool) {
    let result_path = out_path.as_ref().join("stm32_hal_bindings.rs");
    let should_build = !result_path.is_file() || force;
    if !should_build {
        return;
    }

    println!("cargo:warning=writing STM32 HAL bindings");

    #[rustfmt::skip]
    let builder = stm32_builder()
        .whitelist_recursively(false)

        .header(format!("{}/Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h", STM32_SDK_ROOT))

        .whitelist_type("HAL_StatusTypeDef")
        .rustified_enum("HAL_StatusTypeDef")

        .whitelist_type("GPIO_TypeDef")
        .opaque_type("GPIO_TypeDef")
        .whitelist_type("GPIO_PinState")
        .rustified_enum("GPIO_PinState")
        .whitelist_function("HAL_GPIO_WritePin")
        .whitelist_function("HAL_GPIO_TogglePin")
        .whitelist_function("HAL_GPIO_ReadPin")

        .whitelist_type("UART_HandleTypeDef")
        .opaque_type("UART_HandleTypeDef")
        .whitelist_function("HAL_UART_Transmit_IT")

        .whitelist_type("SPI_HandleTypeDef")
        .opaque_type("SPI_HandleTypeDef")
        .whitelist_function("HAL_SPI_Transmit_IT")
        .whitelist_function("HAL_SPI_Receive_IT")
        .whitelist_function("HAL_SPI_TransmitReceive_IT")
    ;

    let bindings = builder.generate().expect("Unable to generate bindings");

    bindings
        .write_to_file(result_path)
        .expect("Couldn't write bindings!");
}

fn generate_stm32_hal_statics<P: AsRef<Path>>(out_path: P, force: bool) {
    let result_path = out_path.as_ref().join("stm32_hal_statics.rs");
    let should_build = !result_path.is_file() || force;
    if !should_build {
        return;
    }

    println!("cargo:warning=writing STM32 HAL bindings");

    #[rustfmt::skip]
    let builder = stm32_builder()
        .whitelist_recursively(false)

        .header(format!("{}/Src/main.c", STM32_SDK_ROOT))

        .whitelist_var(".*_Pin")
        .whitelist_var(".*_Port")

        .whitelist_var("HAL_.*_Pin")
        .whitelist_var("HAL_.*_Port")
//        .whitelist_var("hadc[0-9]+")
        .whitelist_var("hspi[0-9]+")
        .whitelist_var("huart[0-9]+")
//     TODO move timers here
//        .whitelist_var("htim[0-9]+")
        ;

    let bindings = builder.generate().expect("Unable to generate bindings");

    bindings
        .write_to_file(result_path)
        .expect("Couldn't write bindings!");
}
